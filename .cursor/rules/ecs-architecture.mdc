# ECSアーキテクチャ完全移行ルール

## 🎯 **基本原則**

本プロジェクトは**完全なECS（Entity-Component-System）アーキテクチャ**への移行を目標とし、従来のOOPベースの設計から脱却します。

### **ECSの3つの核心要素**

1. **Entity（エンティティ）**: 純粋なIDのみ、データやロジックを持たない
2. **Component（コンポーネント）**: 純粋なデータ構造、ロジックを含まない
3. **System（システム）**: 特定のコンポーネントを持つエンティティを処理するロジック

## 🚫 **禁止事項**

### **1. エンティティがコンポーネントを直接管理**
```typescript
// ❌ 禁止: 現在の実装
export class BaseGameEntity {
    public components: Component[]; // エンティティがコンポーネントを直接管理
}

// ✅ 推奨: 純粋なエンティティ
export interface Entity {
    id: string; // IDのみ
}
```

### **2. コンポーネントにロジックを含める**
```typescript
// ❌ 禁止: ロジックを含むコンポーネント
export abstract class BaseComponent {
    abstract execute(context: GameContext): ComponentResult; // ロジックを含む
}

// ✅ 推奨: 純粋なデータ構造
export interface Component {
    id: string;
    type: ComponentType;
    data: ComponentData; // データのみ
}
```

### **3. システムがエンティティを直接操作**
```typescript
// ❌ 禁止: エンティティの直接操作
export class CombatSystem {
    executeAttack(params: AttackParams): CombatResult {
        // エンティティを直接操作
    }
}

// ✅ 推奨: コンポーネントベースの処理
export class CombatSystem {
    process(entities: Entity[], components: ComponentMap): void {
        // コンポーネントベースの処理
    }
}
```

## ✅ **実装ガイドライン**

### **1. コンポーネントの設計**

#### **純粋なデータ構造**
```typescript
// 位置コンポーネント
export interface PositionComponent {
    x: number;
    y: number;
}

// 移動コンポーネント
export interface MovementComponent {
    distance: number;
    directions: Direction[];
    restrictions: string[];
}

// 生命値コンポーネント
export interface HealthComponent {
    maxHealth: number;
    currentHealth: number;
}
```

#### **SoA（Structure of Arrays）パターンの採用**
```typescript
// パフォーマンス重視のSoA
export const Position = {
    x: new Float64Array(10000),  // x座標の配列
    y: new Float64Array(10000)   // y座標の配列
}

// メモリ効率のSoA
export const Position = {
    x: [] as number[],
    y: [] as number[]
}
```

### **2. システムの実装**

#### **クエリベースの処理**
```typescript
export class MovementSystem extends EntitySystem {
    constructor() {
        super(Matcher.all(PositionComponent, VelocityComponent));
    }
    
    protected process(entities: Entity[]): void {
        for (const entity of entities) {
            const position = entity.getComponent(PositionComponent)!;
            const velocity = entity.getComponent(VelocityComponent)!;
            
            // 位置更新ロジック
            position.x += velocity.x * Time.deltaTime;
            position.y += velocity.y * Time.deltaTime;
        }
    }
}
```

#### **システムのライフサイクル管理**
```typescript
export class ExampleSystem extends EntitySystem {
    protected onInitialize() {
        // システム初期化時の処理
        const eventBus = this.scene.entityManager.eventBus;
        eventBus.on('someEvent', this.handleEvent, { context: this });
    }
    
    protected onBegin() {
        // フレーム開始時の処理
        this.frameCounter++;
    }
    
    protected process(entities: Entity[]) {
        // メイン処理ロジック
        for (const entity of entities) {
            this.processEntity(entity);
        }
    }
    
    protected lateProcess(entities: Entity[]) {
        // 後処理
        this.handlePostProcessing();
    }
    
    protected onEnd() {
        // フレーム終了時の処理
        this.updateStatistics();
    }
}
```

### **3. エンティティ管理**

#### **コンポーネントマネージャーの使用**
```typescript
export class ComponentManager {
    private entityComponents: Map<string, Map<ComponentType, Component>> = new Map();
    
    addComponent(entityId: string, component: Component): void
    getComponent(entityId: string, type: ComponentType): Component | undefined
    getComponentsByType(type: ComponentType): Component[]
    removeComponent(entityId: string, type: ComponentType): boolean
}
```

#### **Archetypeシステムの導入**
```typescript
// 同じコンポーネント組み合わせのエンティティを自動グループ化
const movableArchetype = [Position, Velocity, !Frozen];
const movableEntities = archetypeSystem.getEntities(movableArchetype);
// 直接処理、個別チェック不要
```

## 🚀 **パフォーマンス最適化**

### **1. クエリシステムの最適化**
```typescript
// ❌ 非効率: 線形検索 O(n)
function findEntitiesWithHealth() {
    const result = [];
    for (const entity of allEntities) {
        if (entity.hasComponent(HealthComponent)) {
            result.push(entity);
        }
    }
    return result;
}

// ✅ 効率: クエリシステム O(1)
const entitiesWithHealth = entityManager.query()
    .withAll(HealthComponent)
    .execute(); // 直接取得、SparseSet自動最適化
```

### **2. バッチ操作**
```typescript
// 効率的なバッチ作成
const entities = scene.createEntities(10000, "Bullets");

// バッチクエリ最適化
const movingEntities = scene.querySystem
    .queryAll(PositionComponent, VelocityComponent)
    .entities;
```

### **3. 並列処理**
```typescript
// マルチスレッドクエリ実行
const runner = new ParallelJobRunner(Environment.ProcessorCount);
const store = new EntityStore { JobRunner = runner };

const queryJob = query.ForEach((myComponents, entities) => {
    // 全利用可能コアでマルチスレッド実行
    for (int n = 0; n < entities.Length; n++) {
        myComponents[n].value += 10;
    }
});
queryJob.RunParallel();
```

## 🔧 **実装時の制約事項**

### **1. 構造変更の制約**
```typescript
// ❌ 禁止: クエリループ内での構造変更
query.ForEachEntity((ref Position position, Entity entity) => {
    // StructuralChangeExceptionが発生
    entity.AddComponent(new EntityName("test"));
});

// ✅ 解決: CommandBufferの使用
var buffer = store.GetCommandBuffer();
query.ForEachEntity((ref Position position, Entity entity) => {
    buffer.AddComponent(entity.Id, new EntityName("test"));
});
buffer.Playback(); // ループ終了後に適用
```

### **2. イベントシステム**
```typescript
// 型安全なイベント定義
enum GameEvents {
    PLAYER_DIED = 'player:died',
    LEVEL_COMPLETED = 'level:completed'
}

// イベントの発行と購読
eventBus.emit(GameEvents.PLAYER_DIED, { playerId: 123 });
eventBus.on(GameEvents.PLAYER_DIED, (data) => {
    // dataの型が自動推論される
});
```

## 📋 **移行チェックリスト**

### **Phase 1: 基盤の再構築**
- [ ] 純粋なECSアーキテクチャの実装
- [ ] データとロジックの完全分離
- [ ] Archetypeシステムの導入
- [ ] コンポーネントマネージャーの実装

### **Phase 2: パフォーマンス最適化**
- [ ] SoAパターンの採用
- [ ] クエリシステムの最適化
- [ ] 並列処理の導入
- [ ] バッチ操作の実装

### **Phase 3: 高度な機能**
- [ ] イベントシステムの実装
- [ ] コンポーネントの観察システム
- [ ] シリアライゼーション機能
- [ ] ネットワーク同期機能

## 🎮 **具体的な実装例**

### **2Dプラットフォーマーのコンポーネント**
```typescript
export interface HealthComponent {
    maxHealth: number;
    currentHealth: number;
}

export interface AnimationComponent {
    currentAnimation: string;
    frameIndex: number;
    frameTime: number;
}

export interface PhysicsComponent {
    mass: number;
    friction: number;
    isGrounded: boolean;
}
```

### **シーン管理システム**
```typescript
export class GameScene extends Scene {
    public initialize() {
        this.setupEntities();
        this.setupSystems();
    }
    
    private setupSystems() {
        // 実行順序を明確に制御
        this.addEntityProcessor(new PlayerInputSystem()).updateOrder = 0;
        this.addEntityProcessor(new MovementSystem()).updateOrder = 10;
        this.addEntityProcessor(new AISystem()).updateOrder = 15;
        this.addEntityProcessor(new CollisionSystem()).updateOrder = 30;
        this.addEntityProcessor(new RenderSystem()).updateOrder = 100;
    }
}
```

## 📚 **参考資料**

- [ES Engine ECS Framework](https://github.com/esengine/ecs-framework) - TypeScript ECSフレームワーク
- [Friflo ECS](https://github.com/friflo/ecs-wiki) - 高性能C# ECSライブラリ
- [bitECS](https://github.com/natethegreatt/bitecs) - 軽量TypeScript ECSライブラリ

## ⚠️ **注意事項**

1. **段階的移行**: 既存機能を壊さないよう段階的に移行する
2. **パフォーマンス測定**: 各段階でパフォーマンスを測定し、改善を確認する
3. **テスト駆動**: 新機能は必ずテストを書いてから実装する
4. **ドキュメント更新**: 実装と並行してドキュメントを更新する

このルールに従うことで、プロジェクトは完全なECSアーキテクチャに移行し、パフォーマンス、保守性、拡張性が大幅に向上します。
description:
globs:
alwaysApply: true
---
